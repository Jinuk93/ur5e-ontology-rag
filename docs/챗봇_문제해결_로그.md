# 챗봇 문제 해결 로그

> **목적**: 챗봇 개발 과정에서 발생한 문제들과 해결 과정을 기록
> **최종 수정**: 2026-01-24

---

## 목차

1. [채팅 응답 스타일 개선](#1-채팅-응답-스타일-개선)
2. [정의 질문 ABSTAIN 문제 (Fy가 뭐야?)](#2-정의-질문-abstain-문제-fy가-뭐야)
3. [UR5e 정의 질문 ABSTAIN 문제](#3-ur5e-정의-질문-abstain-문제)
4. [Hydration 에러 (Sheet 컴포넌트)](#4-hydration-에러-sheet-컴포넌트)
5. [비교 질문 ABSTAIN 문제](#5-비교-질문-abstain-문제)
6. [알려진 제한사항](#6-알려진-제한사항)
7. [하드코딩된 규칙 완화 및 유연성 확보 (2026-01-24)](#7-하드코딩된-규칙-완화-및-유연성-확보-2026-01-24)
8. [비교 로직 고도화 및 하이브리드 답변 생성 (2026-01-24)](#8-비교-로직-고도화-및-하이브리드-답변-생성-2026-01-24)
9. ["최근 ~ 패턴이 있어?" 질문 오답(100% 예측) 수정 (2026-01-24)](#9-최근--패턴이-있어-질문-오답100-예측-수정-2026-01-24)
10. [진행 기록 규칙 및 스모크 테스트 절차 (2026-01-24)](#10-진행-기록-규칙-및-스모크-테스트-절차-2026-01-24)

---

## 1. 채팅 응답 스타일 개선

### 문제 상황

**질문**: "지금 진동이 심한데..?"

**기존 응답** (문제):
```
현재 Fz 값이 -45.2N으로 정상 범위입니다. PAT_VIBRATION 패턴 감지됨 (신뢰도: 85%). 추정 원인: Joint Wear (신뢰도: 70%), Loose Bolts (신뢰도: 60%). 권장 조치: 진동 패턴 감지 - 볼트 체결 상태 확인
```

**문제점**:
- 한 줄로 나열되어 가독성 떨어짐
- 영어 용어만 사용 (Joint Wear, Loose Bolts)
- 기계적이고 딱딱한 어투

### 원인 분석

`response_generator.py`의 `_generate_template_response()` 메서드가 모든 정보를 단순 문자열 연결로 출력하고 있었음.

### 수정 내용

**파일**: `src/rag/response_generator.py`

1. **번역 사전 추가**:
```python
CAUSE_TRANSLATIONS = {
    "Joint Wear": "관절 마모",
    "Loose Bolts": "볼트 풀림",
    "Collision": "충돌",
    ...
}

PATTERN_TRANSLATIONS = {
    "Collision": "충돌",
    "Overload": "과부하",
    "Drift": "드리프트",
    "Vibration": "진동",
}
```

2. **응답 구조 변경**:
- 대화체 설명 (intro_parts)
- 구조화된 근거 (evidence_parts) - 세로 정렬

3. **출력 형식 변경**:
```python
# 근거를 "-" 불릿으로 세로 정렬
evidence_parts.append(f"- 추정 원인: {cause_kr} (신뢰도: {conf:.0%})")
evidence_parts.append(f"- 예측: {error} 발생 확률 {prob:.0%}")
evidence_parts.append(f"- 권장 조치: {recommendation['immediate']}")
```

### 결과

**개선된 응답**:
```
현재 Fz 값이 -45.2N로, 정상 범위입니다. Vibration (진동) 패턴이 감지되었어요. 원인을 분석해보니, 다음과 같은 가능성이 있습니다.
- 추정 원인: Joint Wear (관절 마모) (신뢰도: 70%)
- 추정 원인: Loose Bolts (볼트 풀림) (신뢰도: 60%)
- 권장 조치: 진동 패턴 감지 - 볼트 체결 상태 확인
```

### 추가 고려사항

- 영어+한글 병기 방식 채택 (기술 용어 학습에 도움)
- 대화체로 친근한 어투 유지

---

## 2. 정의 질문 ABSTAIN 문제 (Fy가 뭐야?)

### 문제 상황

**질문**: "Fy가 무슨뜻이야?"

**응답**: ABSTAIN (해당 질문에 대한 충분한 근거를 찾지 못했습니다)

**문제점**:
- 기본적인 센서 축 정의 질문에 답을 못함
- 초보자가 시스템을 학습하는 데 장애

### 원인 분석

1. **QueryClassifier**: 정의 질문 패턴이 없어서 ONTOLOGY가 아닌 RAG로 분류됨
2. **OntologyEngine**: 정의 질문 처리 로직 자체가 없었음
3. **ResponseGenerator**: definition 타입 결론 처리 로직 없었음

### 수정 내용

#### 파일 1: `src/rag/query_classifier.py`

```python
# 온톨로지 엔티티 정의 질문 패턴 추가
"entity_definition_question": {
    "patterns": [
        r"(Fz|Fx|Fy|Tx|Ty|Tz|UR5e|Axia80)(?:가|이|는|은|의|란|이란)?\s*(뭐|무엇|무슨|어떤|뜻|의미|정의)",
        r"(뭐|무엇|무슨).{0,5}(Fz|Fx|Fy|Tx|Ty|Tz)",
        r"(힘|토크|Force|Torque).{0,5}(센서|축|뭐|무엇)",
    ],
    "weight": 0.95,
},
```

#### 파일 2: `src/ontology/ontology_engine.py`

1. **정의 질문 감지 함수 추가**:
```python
def _is_definition_query(self, query: str) -> bool:
    definition_patterns = [
        r"(뭐|무엇|무슨|어떤|뜻|의미|정의)",
        r"(what|define|mean|explain)",
    ]
    ...
```

2. **정의 질문 처리 함수 추가**:
```python
def _process_entity_definition(self, entity_id: str, entity_type: str = "") -> Optional[Dict]:
    # MeasurementAxis (Fx, Fy, Fz, Tx, Ty, Tz)
    if props.get("measurement_type") == "force":
        description_parts.append(f"{entity_id}는 {axis}축 방향의 힘(Force)을 측정하는 센서 축이에요.")
    ...
```

#### 파일 3: `src/rag/response_generator.py`

```python
# definition 타입 결론 처리
if definitions_found:
    def_parts = []
    for defn in definitions_found:
        def_parts.append(defn["description"])
    return "".join(def_parts)
```

### 결과

**개선된 응답**:
```
Fy는 Y축 방향의 힘(Force)을 측정하는 센서 축이에요. 단위는 N입니다. 정상 범위는 -10~10 N이에요.
```

### 추가 고려사항

- 모든 6축(Fx, Fy, Fz, Tx, Ty, Tz) 정의 질문 지원
- 온톨로지에 정의된 속성(단위, 정상범위) 자동 포함

---

## 3. UR5e 정의 질문 ABSTAIN 문제

### 문제 상황

**질문**: "UR5e의 사용법을 알려줘"

**응답**: ABSTAIN (해당 질문에 대한 충분한 근거를 찾지 못했습니다)

**추가 질문 (사용자)**:
> "근데 일일이 질문에 대해 너가 하드코딩으로 해줘야해...? UR5e에 대한 답도 잘 못하는데, 이정도면 로직에 문제 있는거 아니야?"

### 원인 분석

**문제 1**: QueryClassifier 패턴 미매칭
- 기존 패턴: `(뭐|무엇|무슨|어떤|뜻|의미|정의)` 만 인식
- "사용법", "알려줘" 같은 키워드 미인식

**문제 2**: EntityExtractor에서 UR5e 미추출
- Python regex `\b` (word boundary)가 한글 조사와 함께 작동 안 함
- "UR5e의"에서 `\bUR5e\b` 패턴 매칭 실패
- 한글 문자가 `isalnum: True`로 판정되어 word boundary 작동 안 함

**문제 3**: Value 오추출
- "UR5e"의 "5"가 Value로 잘못 추출됨
- `has_value = True`가 되어 정의 질문 처리 건너뜀

### 수정 내용

#### 파일 1: `src/rag/query_classifier.py`

```python
# 사용법/설명 요청 패턴 추가
"entity_definition_question": {
    "patterns": [
        ...
        r"(UR5e|Axia80|Axia)(?:의|에\s*대한?)?\s*(사용법|사용방법|설명|소개|정보)",
        r"(UR5e|Axia80|Axia).{0,10}(알려|설명해|가르쳐)",
    ],
},
```

#### 파일 2: `src/ontology/ontology_engine.py`

```python
def _is_definition_query(self, query: str) -> bool:
    definition_patterns = [
        r"(뭐|무엇|무슨|어떤|뜻|의미|정의)",
        r"(what|define|mean|explain)",
        # 사용법/설명 요청 패턴 추가
        r"(사용법|사용방법|설명|소개|정보)",
        r"(알려줘|알려주|가르쳐|설명해)",
    ]
    ...
```

#### 파일 3: `src/rag/entity_extractor.py`

1. **장비 패턴 추가** (한국어 조사 지원):
```python
EQUIPMENT_PATTERN = re.compile(
    r'(UR5e|Axia80|Axia)' + KOREAN_PARTICLES,
    re.IGNORECASE
)

def _extract_equipment(self, query: str) -> List[ExtractedEntity]:
    for match in self.EQUIPMENT_PATTERN.finditer(query):
        equipment = match.group(1)
        if equipment.lower() == "ur5e":
            equipment_id = "UR5e"
            equipment_type = "Robot"
        ...
```

2. **Value 오추출 방지**:
```python
def _extract_values(self, query: str) -> List[ExtractedEntity]:
    # 장비명 내부 숫자를 제외하기 위한 패턴
    equipment_pattern = re.compile(r'(UR5e|Axia80)', re.IGNORECASE)
    equipment_spans = [(m.start(), m.end()) for m in equipment_pattern.finditer(query)]

    for match in self.VALUE_PATTERN.finditer(query):
        # 장비명 내부 숫자 필터링
        is_inside_equipment = any(
            eq_start <= match_start < eq_end
            for eq_start, eq_end in equipment_spans
        )
        if is_inside_equipment:
            continue
        ...
```

#### 파일 4: `src/ontology/ontology_engine.py` (Robot 타입 처리)

```python
def _process_entity_definition(self, entity_id: str, entity_type: str = "") -> Optional[Dict]:
    ...
    # Robot (UR5e)
    elif entity_type in ("Robot",) or entity_type_str == "Robot":
        manufacturer = props.get("manufacturer", "")
        payload = props.get("payload_kg", "")
        reach = props.get("reach_mm", "")
        joints = props.get("joints", "")
        description_parts.append(f"{entity_name}은(는) {manufacturer}에서 제조한 협동로봇이에요.")
        if payload:
            description_parts.append(f"최대 {payload}kg까지 들 수 있고,")
        ...
```

### 결과

**개선된 응답**:
```
UR5e 협동로봇은(는) Universal Robots에서 제조한 협동로봇이에요. 최대 5.0kg까지 들 수 있고, 작업 반경은 850mm입니다. 6축 로봇으로 다양한 작업이 가능해요.
```

### 테스트 결과

| 질문 | query_type | abstain | 응답 |
|------|------------|---------|------|
| UR5e가 뭐야? | ontology | false | ✅ UR5e 설명 |
| Axia80 센서 설명해줘 | ontology | false | ✅ Axia80 설명 |
| Fy가 무슨 뜻이야? | ontology | false | ✅ Fy 설명 |

### 아키텍처 관련 사용자 우려

**사용자 질문**: "하드코딩으로 일일이 해줘야해?"

**현재 상황**:
- 규칙 기반 접근법은 새로운 질문 유형마다 패턴 추가 필요
- 확장성에 한계가 있음

**대안 (향후 확장 시 고려)**:
1. **임베딩 기반 분류**: 질문 임베딩과 예시 임베딩의 유사도로 분류
2. **LLM 기반 의도 추출**: GPT/Claude로 직접 질문 의도 분석
3. **Fine-tuned 분류 모델**: KoBERT 등 질문 분류용 fine-tune

**현재 PoC 판단**:
- 도메인이 좁고 (UR5e, Axia80) 질문 패턴이 예측 가능
- 규칙 기반이 빠르고 신뢰성 있음
- 프로덕션 확장 시 위 대안 고려

---

## 수정 파일 요약

| 파일 | 수정 내용 |
|------|----------|
| `src/rag/response_generator.py` | 대화체 응답, 번역 사전, definition 처리 |
| `src/rag/query_classifier.py` | entity_definition_question 패턴 |
| `src/rag/entity_extractor.py` | EQUIPMENT_PATTERN, Value 오추출 방지 |
| `src/ontology/ontology_engine.py` | _is_definition_query, _process_entity_definition |

---

## 4. Hydration 에러 (Sheet 컴포넌트)

### 문제 상황

**Console Error**:
```
A tree hydrated but some attributes of the server rendered HTML didn't match the client properties.
This won't be patched up. This can happen if a SSR-ed Client Component used:
...
div hidden={true} style={{user-select:"auto"}}
```

### 원인 분석

- Radix UI의 Sheet(Dialog) 컴포넌트 내부에서 생성하는 hidden div
- SSR과 클라이언트 렌더링 간 `user-select:auto` 스타일 불일치
- 브라우저 확장 프로그램 간섭 가능성도 있음

### 수정 내용

**파일**: `frontend/src/components/ui/sheet.tsx`

```tsx
// Client-only wrapper to prevent hydration mismatch
function SheetPortalWrapper({ children }: { children: React.ReactNode }) {
  const [mounted, setMounted] = React.useState(false)

  React.useEffect(() => {
    setMounted(true)
  }, [])

  if (!mounted) return null

  return <>{children}</>
}

// SheetContent에서 사용
<SheetPortalWrapper>
  <SheetPortal>
    ...
  </SheetPortal>
</SheetPortalWrapper>
```

### 결과

- SSR 시 Sheet 내용이 렌더링되지 않고, 클라이언트 마운트 후에만 렌더링
- Hydration 불일치 방지

---

## 5. 비교 질문 ABSTAIN 문제

### 문제 상황

**질문**: "fz와 fx의 정상 범위 비교해줘"

**응답**: ABSTAIN (확실한 답변을 드리기 어렵습니다. no reasoning chain)

**아이러니**:
- "fz가 뭐야?" → 정상 범위 -60~0 N ✅
- "fx는 뭐야?" → 정상 범위 -10~10 N ✅
- "fz와 fx의 정상 범위 비교해줘" → ABSTAIN ❌

### 원인 분석

1. **QueryClassifier**: 비교 질문 패턴이 HYBRID_INDICATORS에만 있었음
2. **OntologyEngine**: 비교 질문 처리 로직 없음 (개별 엔티티만 처리)

### 수정 내용

#### 파일 1: `src/rag/query_classifier.py`

```python
# ONTOLOGY_INDICATORS에 비교 질문 패턴 추가
"entity_comparison_question": {
    "patterns": [
        r"(Fz|Fx|Fy|Tx|Ty|Tz).{0,10}(와|과|랑).{0,10}(Fz|Fx|Fy|Tx|Ty|Tz).{0,10}(비교|차이|다른)",
        r"(비교|차이).{0,10}(Fz|Fx|Fy|Tx|Ty|Tz).{0,10}(Fz|Fx|Fy|Tx|Ty|Tz)",
        r"(Fz|Fx|Fy|Tx|Ty|Tz).{0,5}(Fz|Fx|Fy|Tx|Ty|Tz).{0,10}(비교|차이|다른)",
    ],
    "weight": 0.9,
},
```

#### 파일 2: `src/ontology/ontology_engine.py`

1. **비교 질문 감지 함수 추가**:
```python
def _is_comparison_query(self, query: str) -> bool:
    comparison_patterns = [
        r"(비교|차이|다른|다르)",
        r"(compare|difference|different|vs)",
    ]
    ...
```

2. **비교 처리 함수 추가**:
```python
def _process_comparison(self, axis_entities: List[Dict], query: str) -> Optional[Dict]:
    # 여러 엔티티 정보 수집
    # 비교 결과 텍스트 생성
    # 차이점 분석 (측정 유형, 정상 범위 등)
    ...
```

3. **엔티티 루프 전에 비교 처리 로직 추가**:
```python
if is_comparison_query and not has_value:
    axis_entities = [e for e in entities if e.get("entity_type") == "MeasurementAxis"]
    if len(axis_entities) >= 2:
        result = self._process_comparison(axis_entities, query)
        ...
```

#### 파일 3: `src/rag/response_generator.py`

```python
# comparison 타입 결론 처리
elif c_type == "comparison":
    return conclusion.get("description", "비교 결과를 생성할 수 없습니다.")
```

### 결과

**개선된 응답**:
```
- Fz: Z축 힘(Force), 정상 범위 -60~0 N
- Fx: X축 힘(Force), 정상 범위 -10~10 N

차이점:
- 정상 범위 폭이 다릅니다 (Fz: 60N, Fx: 20N)
```

---

## 6. 알려진 제한사항

### 6.1 "사용법" vs "정의" 구분 미흡

**문제**:
- "UR5e의 사용법을 알려줘" → 정의(스펙) 응답
- 사용자는 "어떻게 사용하는지"를 원하지만, 시스템은 "무엇인지"를 답함

**원인**:
- 현재 시스템이 "사용법"을 정의 질문 패턴에 포함시킴
- 실제 사용법 정보는 온톨로지가 아닌 문서(RAG)에 있어야 함

**PoC 판단**:
- 현재 PoC 범위에서는 온톨로지 기반 정의 응답이 합리적
- 프로덕션에서는 HYBRID 쿼리로 문서 검색 결합 필요

### 6.2 새 질문 유형마다 패턴 추가 필요

**문제**: 규칙 기반 시스템의 한계

**대안 (향후 확장 시)**:
1. 임베딩 기반 질문 분류
2. LLM 의도 추출
3. Fine-tuned 분류 모델

---

## 수정 파일 요약

| 파일 | 수정 내용 |
|------|----------|
| `src/rag/response_generator.py` | 대화체 응답, 번역 사전, definition/comparison 처리 |
| `src/rag/query_classifier.py` | entity_definition_question, entity_comparison_question 패턴 |
| `src/rag/entity_extractor.py` | EQUIPMENT_PATTERN, Value 오추출 방지 |
| `src/ontology/ontology_engine.py` | _is_definition_query, _is_comparison_query, _process_entity_definition, _process_comparison |
| `frontend/src/components/ui/sheet.tsx` | SheetPortalWrapper (hydration 방지) |

---

## 향후 작업 (예정)

- [ ] 더 많은 질문 유형 테스트 및 패턴 보완
- [ ] 에러코드 정의 질문 지원 (C153이 뭐야?)
- [x] ~~복합 질문 처리 (UR5e랑 Axia80의 차이가 뭐야?)~~ → 비교 질문으로 처리
- [ ] 임베딩 기반 분류로 전환 검토
- [ ] "사용법" 질문에 문서 검색(RAG) 결합

---

## 7. 하드코딩된 규칙 완화 및 유연성 확보 (2026-01-24)

### 문제 상황
사용자가 "UR5e 사용법 알려줘"라고 묻거나 "Fx와 Fz 비교해줘"라고 물었을 때, 시스템이 지나치게 경직된 규칙(Regex Rule)을 적용하여 답변을 거부하거나(Definition only), 엉뚱한 값(범위 폭만 비교)을 비교하는 문제가 발생.

### 원인 분석
1. **과도한 정규식 필터링**: `QueryClassifier`가 "사용법", "설명해" 같은 단어를 발견하면 강제로 `ONTOLOGY` 모드(정의 질문)로 분류하여, 매뉴얼 문서 검색 과정을 원천 차단함.
2. **단순한 비교 로직**: `OntologyEngine`의 비교 함수가 엔티티의 Min/Max 값을 비교하지 않고, `Max - Min` (범위의 너비)만 비교하여 "차이가 없다"고 판단하거나 불충분한 정보를 제공함.

### 수정 내용

**파일**: `src/rag/query_classifier.py`
- `entity_definition_question` 패턴에서 "사용법", "설명해", "가르쳐" 등 절차/매뉴얼 관련 키워드를 **삭제**.
- 결과: 이제 "UR5e 사용법"이라고 물으면 온톨로지 정의 룰을 건너뛰고 Hybrid/RAG 검색을 수행하여 PDF 매뉴얼 내용을 답변함.

**파일**: `src/ontology/ontology_engine.py`
- `_process_comparison` 메서드 로직 전면 수정.
- 기존: `if range1 != range2` (폭만 비교)
- 변경: 
  - `Min`과 `Max` 값을 직접 비교.
  - "A가 B보다 최대 허용치가 높습니다"와 같이 구체적인 자연어 문장 생성.
  - 단순 수치 나열이 아니라 의미 있는 차이를 설명하도록 개선.

### 기대 효과
- **유연성 확보**: 챗봇이 모티터링 규칙에만 얽매이지 않고, 문서(PDF) 지식을 활용하여 자연스럽게 대답함.
- **정확성 향상**: "Fz와 Fx 비교" 시, 단순히 "다르다"가 아니라 "Fz가 더 큰 힘을 견딘다"는 구체적 정보 제공.

---

## 8. 비교 로직 고도화 및 하이브리드 답변 생성 (2026-01-24)

### 문제 상황
1. **개념 혼동**: 사용자가 "측정 범위(Spec)"를 물었는데, 챗봇이 "정상 범위(Maintenance)"만 답하거나 두 개념을 혼동하여 답변함.
2. **기계적 어투**: 비교 결과가 Python 코드로 하드코딩된 템플릿 문장(`A > B`)으로만 출력되어 자연스럽지 않고 딱딱함.

### 원인 분석
1. **데이터 구분 미흡**: `_process_comparison`에서 `normal_range`(정상 범위)와 `range`(센서 물리적 한계)를 명확히 구분하여 비교하지 않음.
2. **LLM 활용 부재**: 정밀한 비교 값을 계산해놓고도, 이를 LLM에게 전달하여 자연스러운 문장으로 만들지 않고 `response_generator`의 `_generate_template_response`만 사용함.

### 수정 내용

**1. 로직 고도화 (`src/ontology/ontology_engine.py`)**
- 비교 로직을 **정상 범위(Maintenance)**와 **측정 한계(Spec)** 두 단계로 분리.
- 예: "Fz의 정상 허용치는 Fx보다 좁지만(0 vs 10), 기계적인 측정 한계는 훨씬 큽니다(800 vs 500)."와 같은 입체적 비교 데이터 생성.

**2. 하이브리드 생성 적용 (`src/rag/response_generator.py`, `prompt_builder.py`)**
- **Role Partitioning**: 
  - Python: 정확한 수치 차이(Diff) 계산 100% 담당 (할루시네이션 방지)
  - LLM: 계산된 데이터를 바탕으로 "자연스러운 설명" 생성 담당 (유연성 확보)
- 프롬프트에 "계산된 비교 데이터(Comparison Data)를 근거로 설명하라"는 지침 추가.

### 기대 효과
- **정확성**: 정상 범위와 기계적 스펙을 명확히 구분하여 엔지니어링 관점에서 정확한 비교 제공.
- **자연스러움**: "~값이 큽니다" 같은 기계적 리포트 대신, 문맥을 갖춘 자연스러운 대화형 답변 제공.

---

## 9. "최근 ~ 패턴이 있어?" 질문 오답(100% 예측) 수정 (2026-01-24)

### 문제 상황
- 질문 예: "최근 충돌 패턴이 있어?"
- 챗봇이 실제 센서 이력 조회 없이, 온톨로지 관계(TRIGGERS)를 근거로 **"C153 발생 확률 100%"** 같이 과도하게 단정하는 응답을 생성.

### 원인 분석
1. **최근/이력(Temporal) 질문을 이력 조회로 처리하지 않음**: "최근" 같은 시간 힌트가 엔티티로 잡히지 않거나, 잡혀도 패턴 처리에서 무시되어 단순 온톨로지 추론(원인/연관 에러)로 흘러감.
2. **triggered_error를 예측으로 오인**: `triggered_error` 결론(관계 기반 연결)을 `prediction`으로 변환해 UI에 확률처럼 노출하면서, 사용자가 실제 예측(시간/확률 근거)으로 오해할 수 있었음.

### 수정 내용

**파일**: `src/rag/entity_extractor.py`
- 시간 표현에 "최근/요즘/근래/방금" 등을 추가하여, 이력 질문을 `TimeExpression`로 인식하도록 개선.

**파일**: `src/ontology/ontology_engine.py`
- `TimeExpression`이 있을 때 `context["has_temporal_context"] = True`로 마킹.
- 패턴 처리(`_process_pattern`)에서 시간 컨텍스트가 있으면:
    - 온톨로지 원인/연관 에러 추론 대신
    - `data/sensor/processed/detected_patterns.json` 기반의 **패턴 이력 요약(pattern_history)**을 생성하도록 라우팅.

**파일**: `src/rag/response_generator.py`
- `triggered_error`를 `prediction`으로 변환하지 않도록 변경.
- `pattern_history` 결론이 있을 경우, 요약 문장을 우선 반환하도록 처리.

### 기대 효과
- "최근" 같은 질문은 **실제 데이터(패턴 로그)에 근거**해서 답변.
- 확률(특히 100%) 같은 과도한 단정 표현을 줄이고, 예측은 **실제로 확률 근거가 있는 경우(predictions)**에만 노출.

---

## 10. 진행 기록 규칙 및 스모크 테스트 절차 (2026-01-24)

### 목적
- 앞으로 "문제 발견 → 가설 → 수정 → 검증"을 **누가 봐도 재현 가능**하게 기록하기 위한 공통 포맷.
- 특히 "최근/요즘" 같은 **이력(Temporal) 질문**은 *관계 추론*이 아니라 *로그 조회*로 답해야 하므로, 검증 절차를 표준화.

### 기록 규칙 (매 이슈/수정마다 아래 항목을 채움)
1. **문제 상황**: 어떤 질문/상황에서 어떤 오답/오동작이 났는지 (가능하면 실제 질의문 포함)
2. **기대 동작**: 시스템이 어떤 근거/데이터로 어떻게 답해야 하는지
3. **원인 가설**: 분류기/추출기/추론기/응답기 중 어디가 의심되는지
4. **수정 내용**: 변경한 파일/함수, 변경 요지
5. **검증 방법**: 재현 커맨드/엔드포인트/테스트 케이스
6. **검증 결과**: 통과/실패, 실제 출력(핵심만)
7. **후속 작업**: 남은 TODO (예: "최근"의 기간 정의 확정)

### 스모크 테스트(로컬) - 최근/이력 질문

#### A. 서버 상태 확인
- `GET http://127.0.0.1:8000/health`
    - 기대: 200

#### B. 최소 재현(최근/이력 질문)
- `POST http://127.0.0.1:8000/api/chat`
    - payload 예시: `{ "query": "최근 충돌 패턴이 있어?" }`
    - 기대: 답변에 "예측 100%" 같은 확률 단정이 아니라,
        - 패턴 감지 **횟수/기간/마지막 감지 시각** 등 이력 요약이 포함되거나
        - 데이터가 없으면 "최근 범위에서 감지 없음"처럼 근거 기반으로 응답

#### C. 서버 재시작(Windows)
- 포트 점유 프로세스 확인: `Get-NetTCPConnection -LocalPort 8000 -State Listen | Select-Object -First 1 OwningProcess, State`
- 종료: `Stop-Process -Id <PID> -Force`
- 실행(개발 모드): `python scripts/run_api.py --reload`

### 이번 이슈 진행 기록 (요약)

#### 문제 상황
- "최근 충돌 패턴이 있어?" 같은 질문에서, 이력 조회 없이 관계(TRIGGERS)만으로 "C153 100%"처럼 단정.

#### 수정 내용(이미 적용됨)
- 시간 표현("최근/요즘/근래/방금")을 `TimeExpression`로 인식.
- Temporal 컨텍스트가 있으면 `detected_patterns.json` 기반 `pattern_history` 요약을 생성.
- `triggered_error`는 예측(probability)로 변환하지 않음.

#### 검증 이슈(운영 메모)
- 로컬에서 프로세스 종료 후 `python scripts/run_api.py --reload` 실행이 **Exit Code 1**로 실패한 케이스가 있었음.
    - 가능한 원인: (1) 다른 Python/가상환경 사용으로 의존성(uvicorn 등) 미설치, (2) 포트가 아직 점유 중, (3) 실행 중단/터미널 컨텍스트 충돌.
    - 우선 대응: `GET /health`로 실제 기동 여부를 먼저 확인하고, 필요 시 포트 점유 프로세스를 재확인 후 재기동.

### 다음 확인 포인트
- "최근"의 기준(예: 24시간/7일/전체 기간)을 제품 UX 요구에 맞게 확정.
- UI에서 "관계 기반 연관 에러"와 "확률 기반 예측"을 명확히 구분 표기.
